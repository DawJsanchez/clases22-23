#+Title: Programación de BBDD

* RUTINAS
** Funciones de control de flujo:
   #+BEGIN_SRC sql
	 CASE valor WHEN comparación THEN resultado [WHEN ...][ELSE res] END;
							  # Case operador
	 IF(expr1, expr2, expr3); # IF expr1 DEVUELVE expr2 ELSE expr3
	 IFNULL(expr1, expr2);    # IF expr1 no es Null DEVUELVE expr2
	 NULLIF(expr1, expr2);    # IF expr1 = expr2 DEVUELVE NULL ELSE DEVUELVE expr1
   #+END_SRC

** Lenguajes de programación y BBDD
   Los gesotres de BBDD con el tiempo han ido incorporando características propias de un lenguaje de programación y permiten la integración, el control de flujo y el desarrollo de subrutinas. \\
   Son dependientes del servidor en el que trabajemos, así en SQL-Server (de MS) se denomina Transact-SQL o T-SQL, en Oracle PL/SQL, y MySQL/MariaDB tienen el suyo propio, aunque sin nombre específico. Todos implementan soluciones similares, pero el código no es ~portable~ directamente.
*** Funciones:
**** CREAR (y borrar):
      #+BEGIN_SRC sql
		DELIMITER //
		DROP FUNCTION IF EXISTS tuNombreDeFuncion;
		CREATE FUNCTION tuNombreDeFuncion (Parametero1, Par2, ..., Par_N)
			   # todos los Par son tipo IN
			   RETURNS tipo [DETERMINISTIC]	# INT, CHAR, ...
			   BEGIN
				  # Declarar aquí variables internas a utilizar;

		          DECLARE { CONTINUE | EXIT | UNDO } HANDLER FOR condition_value statement;
		          # maneja excepciones y estados

				  # AQUÍ las sentencias sql a ejecutar

				  RETURN variable;	# del tipo determinado en la línea ~RETURNS~
			   END //
		DELIMITER ;
      #+END_SRC
**** Llamar o invocar:
      #+BEGIN_SRC sql
			SELECT tuNombreDeFuncion( par1 );
      #+END_SRC
**** Mostar:
      #+BEGIN_SRC sql
			SHOW CREATE FUNCTION tuNombreDeFuncion;
      #+END_SRC
*** Procedimientos:
**** CREAR (y borrar):
      #+BEGIN_SRC sql
		DELIMITER //
		DROP PROCEDURE IF EXISTS nombreDelProcedimiento;
		CREATE PROCEDURE nombreDelProcedimiento(IN par1 INT, INOUT par2 VARCHAR(50), ..., OUT parN INT)
		BEGIN
		   DECLARE { CONTINUE | EXIT | UNDO } HANDLER FOR condition_value statement;
		   # maneja excepciones y estados

		   # AQUÍ las sentencias sql a ejecutar
		END //
		DELIMITER ;
      #+END_SRC
**** Llamar o invorcar:
      #+BEGIN_SRC sql
			CALL nombreDelProcedimiento( Par1, Par2, ... ParN );
      #+END_SRC
**** Mostrar:
      #+BEGIN_SRC sql
			SHOW CREATE PROCEDURE tuNombreDeProcedimiento;
      #+END_SRC
*** Triggers (disparadores):
	Un disparador es un objeto de una base de datos que se asocia con una tabla, y se activa cuando ocurre un evento en particular para esa tabla.
**** Crear:
	#+BEGIN_SRC sql
	  CREATE TRIGGER nombre_disparador
			 {BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON nombre_tabla
	            # momento y evento en tabla
			 FOR EACH ROW sentencia_disp
	#+END_SRC
	#+BEGIN_QUOTE
	  Sentencia puede ser una sola o un grupo de sentencias entre ~BEGIN~ y ~END~
	#+END_QUOTE
**** Mostrar:
	 #+BEGIN_SRC sql
	   SHOW TRIGGERS [LIKE 'patron' | WHERE 'condicion'];
	 #+END_SRC
*** Variables:
	#+BEGIN_SRC sql
	  SET @nombre_de_variable = expr [, @var2 = expr2...]
	  SELECT col1 [, col2...] INTO @var1 [, @var2...] FROM... # asigna columnas a variables
	#+END_SRC
*** ~CURSOR~ y ~FETCH~:
	Investigar uso ([[https://dev.mysql.com/doc/refman/8.0/en/cursors.html][CAP 19.2.11, pág 1032, manual de referencia MySQL 5.0]]).


** EXCEPCIONES y MANEJO DE ERRORES
	#+BEGIN_SRC sql
	# En primer lugar renombramos excepciones:
	   DECLARE la_has_liado_parda CONDITION FOR 1217;
	   # Intenta borrar datos en tabla padre con restricciones e hijos presentes.

	# Depués controlamos las excepciones:
	   DECLARE EXIT HANDLER FOR la_has_liado_parda
	   BEGIN
		  ROLLBACK;
		  SELECT 'La has ido liando ... ¡manazas!';
	   END

	# También directamente:
	   DECLARE EXIT HANDLER FOR 1217
	   BEGIN
		  ROLLBACK;
		  SELECT 'La has ido liando ... ¡manazas!';
	   END
	#+END_SRC

** Consultas de interés:
#+BEGIN_SRC sql
	  SHOW DATABASES;		# muestra todas la bases de datos de nuestro servidor SQL.
	  USE nombre_db; 		# utiliza la bbdd ~nombre_db~
	  SHOW TABLES;		  	# muestra todas las tablas de la bbdd
	  DESC nombre_tabla;	# muestra la descripción de la tabla
	  SHOW COLUMNS FROM nombre_tabla;
							# igual que ~DESC nombre_tabla;~
	  SHOW CREATE TABLE nombre_tabla;
							# muestra el ~CREATE TABLE nombre_tabla...~ correspondiente

	  SELECT * FROM information_schema.referential_constraints WHERE constraint_schema = 'database';
							# muestra las claves foráneas y sus restricciones

	  SELECT user, host FROM mysql.user;
			# muestra los usuarios del servidor y la máquina desde la que pueden conectar
			#     ->  Si host es ~%~ equivale a cualquiera
			#     ->  Si host es ~localhost~ sólo podrá loguearse desde la máquina donde se ejecuta el servidor SQL
			#     ->  Si host es una ip o algo como ~10.12.%~ sólo podrá conectarse desde la ip o ips que coincidan con el patrón.
			# ~mysql.user~ -> El prefijo ~mysql~ nos permite acceder a la bbdd aunque no esté en ~uso~. Si la tenemos seleccionada sería innecesario añadirle el prefijo (~...FROM user~).

		SHOW PROCEDURE STATUS WHERE db = 'classicmodels';
		SHOW FUNCTION STATUS WHERE db = 'classicmodels';
			# muestra los procedimientos y funciones de la BBDD

		SET GLOBAL general_log=OFF;
		SET GLOBAL log_output = 'TABLE';
		SET GLOBAL general_log=ON;
		  # los de un alumno concreto
		SELECT event_time, user_host, command_type, CONVERT(argument USING utf8)
		  FROM mysql.general_log
		  WHERE user_host LIKE '%Alfonso%'
		  ORDER BY event_time DESC ;

		  # logs completos
		SELECT event_time, user_host, command_type, CONVERT(argument USING utf8)
		  FROM mysql.general_log
		  ORDER BY event_time DESC ;


		SET GLOBAL log_bin_trust_function_creators = 1;
			# habilita la subida de FUNCIONES sin privilegios
#+END_SRC


** Resumen del RUTINAS
   :PROPERTIES:
   :CUSTOM_ID: programacion-de-bbdd
   :END:

*** Creacion de la bbdd
	:PROPERTIES:
	:CUSTOM_ID: creacion-de-la-bbdd
	:END:

 1. En primer lugar deberéis crear la bbdd y asigarsela a algún usuario.
	\ /Nota:/ Ya lo he hecho por vosotros porque no disponeis de los
	permisos. /Nota 2:/ Para el Proyecto Final Ciclo deberéis realizarlo.
 2. Cargar tablas: \
	=mysql -hdb.luiscastelar.duckdns.org -P45682 -uLuis00 -p$(cat ~/Documentos/secretos/oracle_mysql_Luis00.pass) < nominas21_01_tablas_iniciales.sql 2>&1 | tee nominas21_01_tablas_iniciales.sql.log=
	/Nota:/ Debes sustituir el usuario y el password por los tuyos.

*** Carga de funciones
	:PROPERTIES:
	:CUSTOM_ID: carga-de-funciones
	:END:

 1. =mysql -hdb.luiscastelar.duckdns.org -P45682 -uLuis00 -p$(cat ~/Documentos/secretos/oracle_mysql_Luis00.pass) < nominas21_02_fun_descuentosNomina.sql 2>&1 | tee nominas21_02_fun_descuentosNomina.sql.log=

 2. Ver funciones almacenadas =SHOW FUNCTION STATUS;=

 3. Ver la definición de la función
	=SHOW CREATE FUNCTION descuentosNomina;"=

*** Uso de funciones
	:PROPERTIES:
	:CUSTOM_ID: uso-de-funciones
	:END:

 Prueba/uso de funcionamiento =SELECT descuentosNomina(4.7, 1000);=,
 siendo el primer parámetro el porcentaje de deducción del salario bruto
 que es el segundo parámetro de la función.

*** Carga de procedimientos
	:PROPERTIES:
	:CUSTOM_ID: carga-de-procedimientos
	:END:

 1. La carga es igual que la de las funciones.
 2. Ver procedimientos almacenados =SHOW PROCEDURE STATUS;=
 3. Ver la definición =SHOW CREATE PROCEDURE ...=;
* TRIGGERS
** Referencias:
 + https://phoenixnap.com/kb/mysql-trigger

* PRÁCTICA
Se desea informatizar el servicio de nóminas de una empresa. Para ello deberemos analizar una nómina extrayendo las distintas entidades y relaciones.

Concretamente partiremos de:
#+ATTR_ORG: :width 400
[[./T3-DisenhoFisico/P3-Nominas.drawio.png]]

... \\
 En esta acasión en realidad llegamos a una empresa donde por motivos ajenos nos indican que debemos modificar ciertas tablas según se detalla:
+ EMPRESA (CIF, nombre, dir, cp, prov, ccc, tlfID) => ~empresas (*empresa_id*, /cif/, nombre, dir, cp, prov, /ccc/)~, siendo *id* la clave primaria y, /cif/ y /ccc/ claves candidatas.
+ TRABAJADOR (NIF, nombre, ape1, ape2, tlfID, nss, catID, cotID) => ~trabajadores(*trabajador_id*, /nif/, nombre, ape1, ape2, /nss/, _cat_id_, _cot_id_)~, donde _categoria_id_ y _grupo_de_cotizacion_id_ son claves foráneas a las tablas ~categorias~ y ~grupos_de_cotizacion~ respectivamente.
+ TLF (ID, pre, tlf) => no utilizada
+ CAT (ID, nombreCat) => ~categorias (*categoria_id*, nombre_categoria)~
+ COT (ID, grupo) => ~cotizaciones (*cotizacion_id*, grupo_de_cotizacion)~
+ TCONTRATO (codContrato, nombre) => ~tipos_de_contrato (*tipo_de_contrato_id*, nombre)~
+ CONTRATO (numContrato, fAlta, fBaja, codContrato, NIF, CIF) ) => ~contratos (*contrato_id*, fecha_alta, fecha_baja, /tipo_de_contrato_id/, /trabajador_id/, /empresa_id/)~
+ CONCTIPO (conTipo, nombre, tipo) => ~tipos_de_conceptos (*tipo_de_concepto_id*, nombre, tipo)~
+ CONCSALARIO (ID, numContrato, conTipo, cantidad) => ~conceptos_de_salario (*concepto_id*, /contrato_id/, /tipo_de_concepto_id/, cantidad)~
+ PERCEPCION <= CONCSALARIO => no utilizada
+ BASESCOT (ID, numContrato, cantidad) => ~bases_de_cotizacion (*base_cot_id*, /contrato_id/, cantidad)~
+ BASESTIPOS (ID, nombre, porcentaje) => ~tipos_aplicables (*tipo_base_id*, nombre, porcentaje)~
+ TIPODEDUC (tipoDeduccion, nombre, receptor) => ~tipos_deducciones (*tipo_deduccion_id*, nombre, recpetor)~\\
		Donde el recpetor es:
  + Hacienda para el IRPF, DEDHEXTRA y DEDHEXTRAFM
  + SES para DEDCC
  + SEPE para DEDDES
  + SEXPE para DEDFP
+ DEDUCCION (ID, tipoDeduccion, anho, mes, NIF, numContrato, cantidad) => ~deducciones (*deduccion_id*, /tipo_deduccion_id/, anho, mes, /trabajador_id/,/contrato_id/, cantidad)~

Ahora, deberemos crear un sistema que implemente:
